# AdaptFS Implementation

The main daemon `mount_adaptfs` is a FUSE instance that provides a
generic processing framework and relies on modules for data loading,
interpretation, transformation, and output formatting.

The accompanying program, `adaptctl`, is the main driver for controlling
behavior of `mount_adaptfs`.
This program establishes a connection to a listening UNIX domain socket
inside `mount_adaptfs`.

## Overview

* main.c
  global variable/state initialization; FUSE/PFL FS glue
* fs.c
  non-I/O (i.e. metadata) file system operations e.g. creat(2), rename(2)
* io.c
  I/O operations i.e. read(2) (no write support)
* mod.c
  module interface
* ctl.c
  control interface
* inode.c
  in-memory file structure handling routines

## File System Operations (fs.c)

Most metadata operations in `mount_adaptfs` are no-ops, since no
modification of data is allowed.
Only GETATTR, LOOKUP, OPEN, OPENDIR, READDIR, and RELEASE are
implemented.

Name space lookups via LOOKUP consult the "name to inode" API described
in the File API.
Other implemented operations operate on the fabricated inode numbers
generated by the File API when modules are loaded.

## I/O Operations (io.c)

The core read I/O handling routine is `fsop_read`.
This routine grabs the underlying page.
The current implementation maps a single in-memory page (data buffer)
for the entire virtual file contents.

The design was intended to be split into multiple pages.

Once the page is available for use, provided by `getpage()`, it is
returned.
`getpage()` also ensure the contents are valid.

`getpage()` searches a global hash table for the file's i-number.
Since each virtual file currently only has a single page, this uniquely
identifies the data buffer to service the READ request.

If the page already exists in memory: (1) it is waited on if it isn't
already filled and (2) checked if the contents are valid.
If the contents are not valid (i.e. data has been reaped), the same data
loading logic is executed as in the case that the page was non existent.

If the page is non existent, a `/dev/shm/adaptfs` pathname is created
and `mmap(2)`'d into `mount_adaptfs` memory.
This `/dev/shm` pathname is so external programs can operate directly on
the memory to bypass copying to and from userland and kernel and
external modification programs such as GraphicsMagick.

A data buffer is then allocated via the PFL pool API and initialized and
`mmap(2)`'d to this file.

The current implementation fabricates a PPM file format header to
calculate the virtual file size to service stat(2) requests.

The page is filled according the module (via read callback) that created
the virtual file the page backs and is returned to the application.

## Control API (ctl.c)

The majority of this code is not specific to AdaptFS proper; rather it
is provided by PFL and allows access to data structures, statistics,
counters, etc.

The only routine of interest is `ctlcmd_load` which handles an `adaptctl
load` command, which loads a module.
The module interface is described below.

## Module API (mod.c)

This implements the interface for supporting loadable modules into
mount_adaptfs and some of the APIs exposed to modules for use.

The API defines `instance_load` which is called by the Control API for
handling the details concerned with loading an AdaptFS module.

A structure representing the module is created and initialized.
Arguments to the module are stored and a hash table containing all
inodes (i.e. virtual files) created by the module is created.

The module is then loaded via the dlopen(3) API and the module
initialization callback routine is executed.
This routine (in the module implementation) typically checks the
arguments specified, performs sanity checks, then registers virtual
files that will populate under the module instance name.

## File API (inode.c)










